/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *  http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *  http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CTMLoader = function ( showStatus ) {

    THREE.Loader.call( this, showStatus );

};

THREE.CTMLoader.prototype = Object.create( THREE.Loader.prototype );

// Load multiple CTM parts defined in JSON

THREE.CTMLoader.prototype.loadParts = function( url, callback, parameters ) {

    var scope = this;

    var xhr = new XMLHttpRequest();

    var basePath = parameters.basePath ? parameters.basePath : this.extractUrlBase( url );

    xhr.onreadystatechange = function() {

        if ( xhr.readyState === 4 ) {

            if ( xhr.status === 200 || xhr.status === 0 ) {

                var jsonObject = JSON.parse( xhr.responseText );

                var materials = [], geometries = [], counter = 0;

                function callbackFinal( geometry ) {

                    counter += 1;

                    geometries.push( geometry );

                    if ( counter === jsonObject.offsets.length ) {

                        callback( geometries, materials, jsonObject );

                    }

                }


                // init materials

                for ( var i = 0; i < jsonObject.materials.length; i ++ ) {

                    materials[ i ] = THREE.Loader.prototype.createMaterial( jsonObject.materials[ i ], basePath );

                }

                // load joined CTM file

                var partUrl = basePath + jsonObject.data;
                var parametersPart = { useWorker: parameters.useWorker, useBuffers: parameters.useBuffers, groups: jsonObject.offsets };
                scope.load( partUrl, callbackFinal, parametersPart );

            }

        }

    }

    xhr.open( "GET", url, true );
    xhr.setRequestHeader( "Content-Type", "text/plain" );
    xhr.send( null );

};

// Load CTMLoader compressed models
//  - parameters
//      - url (required)
//      - callback (required)

THREE.CTMLoader.prototype.load = function( url, callback, parameters ) {

    var scope = this;

    var groups = parameters.groups !== undefined ? parameters.groups : [ 0 ];
    var useBuffers = parameters.useBuffers !== undefined ? parameters.useBuffers : true;

    var xhr = new XMLHttpRequest(),
        callbackProgress = null;

    var length = 0;

    xhr.onreadystatechange = function() {

        if ( xhr.readyState === 4 ) {

            if ( xhr.status === 200 || xhr.status === 0 ) {

                var binaryData = new Uint8Array(xhr.response);

                var s = Date.now();

                if ( parameters.useWorker ) {

                    var worker = new Worker( "resources/js/ctm/CTMWorker.js" );

                    worker.onmessage = function( event ) {

                        var ctmFile = event.data;

                        var e1 = Date.now();
                        // console.log( "CTM data parse time [worker]: " + (e1-s) + " ms" );

                        if ( useBuffers ) {

                            scope.createModelBuffers( ctmFile, callback );

                        } else {

                            scope.createModelClassic( ctmFile, callback );

                        }

                        var e = Date.now();
                        console.log( "model load time [worker]: " + (e-e1) + " ms, total: " + (e-s));

                    };

                    worker.postMessage( { "data": binaryData.buffer, "groups": groups } );

                } else {

                    for ( var i = 0; i < groups.length; i ++ ) {

                        var stream = new CTM.Stream( binaryData.buffer );
                        stream.groups = groups[ i ];

                        var ctmFile = new CTM.File( stream );

                        if ( useBuffers ) {

                            scope.createModelBuffers( ctmFile, callback );

                        } else {

                            scope.createModelClassic( ctmFile, callback );

                        }

                    }

                    //var e = Date.now();
                    //console.log( "CTM data parse time [inline]: " + (e-s) + " ms" );

                }

            } else {

                console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

            }

        } else if ( xhr.readyState === 3 ) {

            if ( callbackProgress ) {

                if ( length === 0 ) {

                    length = xhr.getResponseHeader( "Content-Length" );

                }

                callbackProgress( { total: length, loaded: xhr.responseText.length } );

            }

        } else if ( xhr.readyState === 2 ) {

            length = xhr.getResponseHeader( "Content-Length" );

        }

    }

    xhr.open( "GET", url, true );
    xhr.responseType = "arraybuffer";

    xhr.send( null );

};


THREE.CTMLoader.prototype.createModelBuffers = function ( file, callback ) {

    var Model = function ( ) {

        var scope = this;

        THREE.BufferGeometry.call( this );

        var s = Date.now();
        // init GL buffers

        var vertexIndexArray = file.body.indices,
        vertexPositionArray = file.body.vertices,
        vertexNormalArray = file.body.normals;

        var vertexUvArrays = {}, vertexAttrArrays = {}, attr;

        if ( file.body.uvMaps !== undefined ) {
            for (var i = 0; i < file.body.uvMaps.length; i++) {
                attr = file.body.uvMaps[i];
                vertexUvArrays[attr.name] = attr.uv;
            }
        }

        if ( file.body.attrMaps !== undefined ) {
            for (var i = 0; i < file.body.attrMaps.length; i++) {
                attr = file.body.attrMaps[i];
                vertexAttrArrays[attr.name] = attr.attr;
            }
        }

        scope.setIndex(new THREE.BufferAttribute(vertexIndexArray, 1));
        scope.addAttribute("position", new THREE.BufferAttribute(vertexPositionArray, 3));
        if (vertexNormalArray !== undefined) {
            scope.addAttribute("normal", new THREE.BufferAttribute(vertexNormalArray, 3));
        }

        for (var name in vertexUvArrays) {
            scope.addAttribute(name, new THREE.BufferAttribute(vertexUvArrays[name], 2));
        }

        for (var name in vertexAttrArrays) {
            scope.addAttribute(name, new THREE.BufferAttribute(vertexAttrArrays[name], 4));
        }

    }

    Model.prototype = Object.create( THREE.BufferGeometry.prototype );

    var geometry = new Model();

    // compute vertex normals if not present in the CTM model

    if ( geometry.attributes[ "normal" ] === undefined ) {

        geometry.computeVertexNormals();

    }

    callback( geometry );

};
