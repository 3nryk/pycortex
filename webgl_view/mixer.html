<!doctype html>
<html lang="en">
    <head>
        <title>three.js webgl - loaders - vtk loader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background-color: #888;
                color: #fff;
                margin: 0px;
                overflow: hidden;
            }
            #threeDview {
                text-align:center;
                font-size:48pt;
                font-family:sans-serif;
            }
        </style>
        <script src="resources/js/Three.js"></script>
        <script src='resources/js/jquery-1.7.2.min.js'></script>
        <script src='resources/js/LandscapeControls.js'></script>
        <script src="js/loaders/ctm/lzma.js"></script>
        <script src="js/loaders/ctm/ctm.js"></script>
        <script src="js/loaders/ctm/CTMLoader.js"></script>

        <script type='text/javascript'>
        var vertexShader = [

            "attribute vec2 datamap;",
            "uniform sampler2D data;",
            "uniform vec2 datasize;",
            "uniform vec2 dsamp;",

            "uniform sampler2D colormap;",
            "uniform float vmin;",
            "uniform float vmax;",

            "varying vec3 vViewPosition;",
            "varying vec3 vNormal;",

            THREE.ShaderChunk[ "map_pars_vertex" ],
            THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "morphtarget_pars_vertex" ],

            "void main() {",

                "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

                THREE.ShaderChunk[ "map_vertex" ],
                
                "vec2 dcoord = (2.*datamap.yx+1.) / (2.*datasize.xy);",
                "float vdata = texture2D(data, dcoord).r;",
                "float vnorm = (vdata - vmin) / (vmax - vmin);",
                //"vColor = texture2D(data, dsamp).rgb;",
                "vColor = texture2D(colormap, vec2(vnorm, 0 )).rgb;",
                //"vColor = texture2D(colormap, (2*vec2(datamap.x, 0)-1) / (2*datasize)).rgb;",
                //"vColor = vec3(datamap.x / 115.);",

                "vViewPosition = -mvPosition.xyz;",

                THREE.ShaderChunk[ "morphnormal_vertex" ],

                "vNormal = transformedNormal;",

                THREE.ShaderChunk[ "lights_phong_vertex" ],
                THREE.ShaderChunk[ "morphtarget_vertex" ],
                THREE.ShaderChunk[ "default_vertex" ],

            "}"

        ].join("\n");
        var fragmentShader = [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            "uniform vec3 ambient;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",

            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "lights_phong_pars_fragment" ],

            "void main() {",

                "gl_FragColor = vec4( vec3(1.0), opacity);",
                THREE.ShaderChunk[ "map_fragment" ],

                THREE.ShaderChunk[ "lights_phong_fragment" ],

                THREE.ShaderChunk[ "color_fragment" ],

                //THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

            "}"

        ].join("\n");


        var colormaps = {

            redblue: function() {
                var cmap = new Uint8Array(256*3);

                for (var i = 0; i < 256; i++) {
                    cmap[i*3] = i;
                    cmap[i*3+2] = 255 - i;
                }

                var tex = new THREE.DataTexture(cmap, 256, 1, THREE.RGBFormat);
                tex.needsUpdate = true;
                return tex;
            }(),

            RdBu_r: THREE.ImageUtils.loadTexture("RdBu_r.png"),

        }

        

        function MRIview(data) {
            this.container = $("#threeDview")
            // scene and camera
            this.scene = new THREE.Scene();

            this.camera = new THREE.PerspectiveCamera( 60, window.innerWidth / (window.innerHeight-80), 0.1, 5000 );
            this.camera.position.x = 200;
            this.camera.position.y = 200;
            this.camera.position.z = 0;
            this.camera.lookAt(new THREE.Vector3(0,0,0));

            this.scene.add( this.camera );

            this.controls = new THREE.LandscapeControls( this.camera, this.container[0] );

            this.controls.rotateSpeed = 5.0;
            this.controls.zoomSpeed = 20;
            this.controls.panSpeed = 2;

            this.controls.noZoom = false;
            this.controls.noPan = false;

            this.controls.staticMoving = true;
            this.controls.dynamicDampingFactor = 0.3;

            var dirLight = new THREE.DirectionalLight( 0xffffff );
            dirLight.position.set( 200, 200, 1000 ).normalize();
            this.camera.add( dirLight );
            //this.camera.add( dirLight.target );
            this.light = dirLight;

            // renderer
            this.renderer = new THREE.WebGLRenderer( { antialias: false } );
            this.renderer.setClearColorHex( 0x888888, 1 );
            this.renderer.setSize( window.innerWidth,window.innerHeight-50);

            this.datatex =  new THREE.DataTexture(data, 256, data.length/4 / 256);
            this.datatex.needsUpdate = true;
            this.datatex.flipY = false;
            this.datatex.minFilter = THREE.NearestFilter;
            this.datatex.maxFilter = THREE.NearestFilter;

            var uniforms = THREE.UniformsUtils.merge( [
                THREE.UniformsLib[ "lights" ],
                {
                    diffuse:    { type:'v3', value:new THREE.Vector3( 1,1,1 )},
                    specular:   { type:'v3', value:new THREE.Vector3( 1,1,1 )},
                    emissive:    { type:'v3', value:new THREE.Vector3( 0.05,0.05,0.05 )},
                    shininess:  { type:'f', value:200},
                    opacity:    { type:'f', value:1 },

                    colormap:   { type:'t', value:0, texture: null },
                    data:       { type:'t', value:1, texture: null },
                    dsamp:      { type:'v2', value:new THREE.Vector2(1., 0.)},
                    datasize:   { type:'v2', value:new THREE.Vector2(this.datatex.image.width, this.datatex.image.height)},

                    vmin:{ type:'f', value: 0},
                    vmax:{ type:'f', value: 1},
                }
            ])
            uniforms.data.texture = this.datatex;
            uniforms.colormap.texture = colormaps.RdBu_r;

            this.shader = new THREE.ShaderMaterial( { 
                vertexShader:vertexShader,
                fragmentShader:fragmentShader,
                uniforms: uniforms,
                attributes: {
                    datamap:true,
                },
                morphTargets:true, 
                morphNormals:true, 
                lights:true, 
                vertexColors:true
            });
            
            this.container.html( this.renderer.domElement );
            $(window).resize(this.resize.bind(this));
            this.slider = $("#mix").width(window.innerWidth);
            var _this = this;
            this.slider.change(function() {
                _this.setMix(this.value/10000);
            });
            this.pivslider = $("#pivot").width(window.innerWidth);
            this.pivslider.change(function() {
                _this.setPivot(this.value / 10);
            })
        }
        MRIview.prototype = { 
            draw: function () {
                requestAnimationFrame( this.draw.bind(this) );
                this.controls.update();
                this.renderer.render( this.scene, this.camera );
            },
            load: function(subj) {
                $(this.renderer.domElement).remove();
                this.container.html("Loading...");
                if (this.meshes) {
                    for (var hemi in this.meshes) {
                        this.scene.remove(this.meshes[hemi]);
                        delete this.meshes[hemi];
                    }
                    delete this.meshes;
                }
                
                this.loader = new THREE.CTMLoader(  );
                var ctminfo = "resources/ctm/AH_AH_huth_[inflated,superinflated].json";
                this.loader.loadParts( ctminfo, function( geometries, materials, header, json ) {
                    var geom;
                    
                    var rawdata = new Uint32Array(header.length / 4);
                    var charview = new Uint8Array(rawdata.buffer);
                    for (var i = 0, il = header.length; i < il; i++) {
                        charview[i] = header.charCodeAt(i);
                    }

                    var polyfilt = {};
                    polyfilt.left = rawdata.subarray(2, rawdata[0]+2);
                    polyfilt.right = rawdata.subarray(rawdata[0]+2);
                    
                    this.meshes = {};
                    this.pivot = {};
                    var names = {left:0, right:1};
                    for (var name in names) {
                        geom = geometries[names[name]];
                        geom.computeBoundingBox();
                        geom.computeBoundingSphere();
                        geom.dynamic = true;
                        
                        var uv = geom.attributes.uv.array;
                        var flat = new Float32Array(uv.length / 2 * 3);
                        var norms = new Float32Array(uv.length / 2 * 3);
                        var lim = json.flatlims[names[name]];
                        var flip = 2*names[name]-1;
                        var yrange = geom.boundingBox.max.y - geom.boundingBox.min.y, ymin = geom.boundingBox.min.y;
                        var zrange = geom.boundingBox.max.z - geom.boundingBox.min.z, zmin = geom.boundingBox.min.z;
                        for (var i = 0, il = uv.length / 2; i < il; i++) {
                            flat[i*3+1] = (uv[i*2] - lim[0]) / lim[1];
                            if (!names[name]) {
                                flat[i*3] = geom.boundingBox.min.x / 3;
                                flat[i*3+1] = 1 - flat[i*3+1]
                            } else {
                                flat[i*3] = geom.boundingBox.max.x / 3;
                            }

                            flat[i*3+1] = 1.2*(flat[i*3+1] * yrange + ymin);
                            flat[i*3+2] = 1.2*(uv[i*2+1] *lim[2]* yrange + zmin);
                            norms[i*3] = flip;
                        }
                        geom.morphTargets.push({ array:flat, stride:3 })
                        geom.morphNormals.push( norms );

                        var polys = new Uint16Array(geom.attributes.index.array.length - polyfilt[name].length*3);
                        var j = 0;
                        for (var i = 0, il = geom.attributes.index.array.length / 3; i < il; i++) {
                            if (i != polyfilt[name][i-j]) {
                                polys[j*3]   = geom.attributes.index.array[i*3];
                                polys[j*3+1] = geom.attributes.index.array[i*3+1];
                                polys[j*3+2] = geom.attributes.index.array[i*3+2];
                                j++;
                            }
                        }
                        geom.attributes.flatindex = {itemsize:1, array:polys, numItems:polys.length};

                        var mesh = new THREE.Mesh(geom, this.shader);
                        mesh.position.y = -1.2*geom.boundingBox.min.y;
                        this.meshes[name] = mesh;
                        this.pivot[name] = {back:new THREE.Object3D(), front:new THREE.Object3D()};
                        this.pivot[name].back.add(mesh);
                        this.pivot[name].front.add(this.pivot[name].back);
                        this.pivot[name].back.position.y = 1.2*(geom.boundingBox.min.y - geom.boundingBox.max.y);
                        this.pivot[name].front.position.y = 1.2*geom.boundingBox.max.y;
                        this.scene.add(this.pivot[name].front);
                    }
                    this.indexswap = {};
                    this.indexswap.left = geometries[0].attributes.flatindex;
                    this.indexswap.right = geometries[1].attributes.flatindex;
                    this.container.html(this.renderer.domElement);
                    this.draw();

                }.bind(this), true, true );

            },
            resize: function() {
                this.renderer.setSize(window.innerWidth, window.innerHeight-80);
                this.camera.aspect = window.innerWidth / (window.innerHeight-80);
                this.camera.updateProjectionMatrix();
                this.slider.width(window.innerWidth);
                this.pivslider.width(window.innerWidth);
            },
            setMix: function(val) {
                var num = this.meshes.left.geometry.morphTargets.length;
                var flat = num - 1;
                var n1 = Math.floor(val * num)-1;
                var n2 = Math.ceil(val * num)-1;

                for (var h in this.meshes) {
                    var hemi = this.meshes[h];
                    
                    for (var i=0; i < num; i++)
                        hemi.morphTargetInfluences[i] = 0;

                    if ((this.lastn2 == flat) ^ (n2 == flat)) {
                        var tmpbuf = this.indexswap[h];
                        this.indexswap[h] = hemi.geometry.attributes.index;
                        hemi.geometry.attributes.index = tmpbuf;
                    }
                    if (n2 == flat)
                        this.setPivot(((val*num-.000001)%1)*180);
                    else 
                        this.setPivot(0);

                    hemi.morphTargetInfluences[n2] = (val * num)%1;
                    if (n1 >= 0)
                        hemi.morphTargetInfluences[n1] = 1 - (val * num)%1;
                }
                this.lastn2 = n2;
            }, 
            setPivot: function (val) {
                $("#pivot").attr("value", val*10);
                var names = {left:1, right:-1}
                if (val > 0) {
                    for (var name in names) {
                        this.pivot[name].front.rotation.z = 0;
                        this.pivot[name].back.rotation.z = val*Math.PI/180 * names[name]/ 2;
                    }
                } else {
                    for (var name in names) {
                        this.pivot[name].back.rotation.z = 0;
                        this.pivot[name].front.rotation.z = val*Math.PI/180 * names[name] / 2;
                    }
                }
            }
        }
        var viewer;
        $(document).ready(function() {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'corrdata.bin', true);
            xhr.responseType = 'arraybuffer';

            xhr.onload = function(e) {
                if (this.status == 200) {
                    var head = new Float32Array(this.response.slice(0, 8*4));
                    var data = new Uint8Array(this.response.slice(8*4));
                    console.log(head);
                    viewer = new MRIview(data);
                    viewer.load();
                } else {
                    console.log(this.status);
                }
            };
            xhr.send();
        });
        </script>
    </head>

    <body>
        <div id='threeDview'>
            Loading...
        </div>
        <input id="mix" type="range" min="0" max="10000" value="0">
        <input id="pivot" type="range" min="-1800" max="1800" value="0">
    </body>
</html>
